"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ethernal = void 0;
const message_trace_1 = require("hardhat/internal/hardhat-network/stack-traces/message-trace");
const firebase = require('./firebase');
var logger = (message) => {
    console.log(`[Ethernal] `, message);
};
class Ethernal {
    constructor(hre) {
        this.env = hre;
        this.db = new firebase.DB();
        this.trace = [];
        this.syncNextBlock = true;
    }
    async startListening() {
        const envSet = await this.setLocalEnvironment();
        if (!envSet) {
            return;
        }
        if (this.env.config.ethernal.resetOnStart)
            await this.resetWorkspace(this.env.config.ethernal.resetOnStart);
        this.syncNextBlock = false;
        this.env.ethers.provider.on('block', (blockNumber, error) => {
            if (blockNumber == 0 || this.syncNextBlock) {
                this.syncNextBlock = true;
                this.onData(blockNumber, error);
            }
            else {
                logger(`Skipping block ${blockNumber}`);
                this.syncNextBlock = true;
            }
        });
        this.env.ethers.provider.on('error', (error) => this.onError(error));
        this.env.ethers.provider.on('pending', () => this.onPending());
    }
    async push(targetContract) {
        if (this.env.config.ethernal.disabled) {
            return;
        }
        const envSet = await this.setLocalEnvironment();
        if (!envSet) {
            return;
        }
        this.targetContract = targetContract;
        if (!this.targetContract.name || !this.targetContract.address) {
            return logger('Contract name and address are mandatory');
        }
        const contract = await this.getFormattedArtifact(targetContract);
        if (!contract) {
            return;
        }
        if (this.env.config.ethernal.uploadAst) {
            logger('Uploading contract AST, this might take a while depending on the size of your contract.');
            var storeArtifactRes = await firebase.functions.httpsCallable('syncContractArtifact')({
                workspace: this.db.workspace.name,
                address: contract.address,
                artifact: contract.artifact
            });
            if (!storeArtifactRes.data) {
                return logger(storeArtifactRes);
            }
        }
        var contractSyncRes = await firebase.functions.httpsCallable('syncContractData')({
            workspace: this.db.workspace.name,
            name: contract.name,
            address: contract.address,
            abi: contract.abi
        });
        if (!contractSyncRes.data) {
            return logger(contractSyncRes);
        }
        if (this.env.config.ethernal.uploadAst) {
            logger('Uploading dependencies ASTs, this might take a while depending on the size of your contracts.');
            try {
                const dependenciesPromises = [];
                for (const dep in contract.dependencies)
                    dependenciesPromises.push(firebase.functions.httpsCallable('syncContractDependencies')({
                        workspace: this.db.workspace.name,
                        address: contract.address,
                        dependencies: { [dep]: contract.dependencies[dep] }
                    }));
                await Promise.all(dependenciesPromises);
            }
            catch (error) {
                logger(`Couldn't sync dependencies: ${error.message}`);
            }
        }
        const dependencies = Object.entries(contract.dependencies).map(art => art[0]);
        const dependenciesString = dependencies.length ? ` Dependencies: ${dependencies.join(', ')}` : '';
        logger(`Updated artifacts for contract ${contract.name} (${contract.address}).${dependenciesString}`);
    }
    async traceHandler(trace, isMessageTraceFromACall) {
        if (this.env.config.ethernal.disabled) {
            return;
        }
        if (this.env.config.ethernal.disableTrace)
            return;
        await this.setLocalEnvironment();
        const envSet = await this.setLocalEnvironment();
        if (!envSet)
            return;
        logger('Tracing transaction...');
        let stepper = async (step) => {
            if ((0, message_trace_1.isEvmStep)(step) || (0, message_trace_1.isPrecompileTrace)(step))
                return;
            if ((0, message_trace_1.isCreateTrace)(step) && step.deployedContract) {
                const address = `0x${step.deployedContract.toString('hex')}`;
                const bytecode = await this.env.ethers.provider.getCode(address);
                this.trace.push({
                    op: 'CREATE2',
                    contractHashedBytecode: this.env.ethers.utils.keccak256(bytecode),
                    address: address,
                    depth: step.depth
                });
            }
            if ((0, message_trace_1.isCallTrace)(step)) {
                const address = `0x${step.address.toString('hex')}`;
                const bytecode = await this.env.ethers.provider.getCode(address);
                this.trace.push({
                    op: 'CALL',
                    contractHashedBytecode: this.env.ethers.utils.keccak256(bytecode),
                    address: address,
                    input: step.calldata.toString('hex'),
                    depth: step.depth,
                    returnData: step.returnData.toString('hex')
                });
            }
            for (var i = 0; i < step.steps.length; i++) {
                await stepper(step.steps[i]);
            }
        };
        if (this.trace) {
            this.trace = [];
            if (!(0, message_trace_1.isEvmStep)(trace) && !(0, message_trace_1.isPrecompileTrace)(trace)) {
                for (const step of trace.steps) {
                    stepper(step);
                }
            }
        }
    }
    async resetWorkspace(workspace) {
        if (this.env.config.ethernal.disabled) {
            return;
        }
        const envSet = await this.setLocalEnvironment();
        if (!envSet) {
            return;
        }
        logger(`Resetting workspace "${workspace}"...`);
        try {
            await firebase.functions.httpsCallable('resetWorkspace')({ workspace: workspace });
            logger(`Workspace "${workspace}" has been reset!`);
        }
        catch (error) {
            logger(`Error while resetting workspace "${workspace}": ${error.message}`);
        }
    }
    onData(blockNumber, error) {
        if (error && error.reason) {
            return logger(`Error while receiving data: ${error.reason}`);
        }
        if (this.env.config.ethernal.serverSync) {
            logger(`Syncing block #${blockNumber}...`);
            firebase.functions
                .httpsCallable('serverSideBlockSync')({ blockNumber: blockNumber, workspace: this.db.workspace.name })
                .catch(console.log);
        }
        else
            this.env.ethers.provider.getBlockWithTransactions(blockNumber).then((block) => this.syncBlock(block));
    }
    onError(error) {
        if (error && error.reason) {
            logger(`Could not connect to ${this.env.ethers.provider}. Error: ${error.reason}`);
        }
        else {
            logger(`Could not connect to ${this.env.ethers.provider}.`);
        }
    }
    async setLocalEnvironment() {
        if (this.db.userId && this.db.workspace) {
            return true;
        }
        const user = await this.login();
        if (!user) {
            return false;
        }
        await this.setWorkspace();
        if (!this.db.workspace)
            return false;
        return true;
    }
    onPending() {
        //TODO: to implement
    }
    syncBlock(block) {
        if (block) {
            firebase.functions.httpsCallable('syncBlock')({ block: block, workspace: this.db.workspace.name })
                .then(({ data }) => {
                logger(`Synced block #${data.blockNumber}`);
                for (let i = 0; i < block.transactions.length; i++) {
                    const transaction = block.transactions[i];
                    this.env.ethers.provider.getTransactionReceipt(transaction.hash).then((receipt) => this.syncTransaction(block, transaction, receipt));
                }
            });
        }
    }
    stringifyBns(obj) {
        var res = {};
        for (const key in obj) {
            if (this.env.ethers.BigNumber.isBigNumber(obj[key])) {
                res[key] = obj[key].toString();
            }
            else {
                res[key] = obj[key];
            }
        }
        return res;
    }
    syncTransaction(block, transaction, transactionReceipt) {
        return firebase.functions.httpsCallable('syncTransaction')({
            block: block,
            transaction: transaction,
            transactionReceipt: transactionReceipt,
            workspace: this.db.workspace.name
        })
            .then(({ data }) => {
            if (this.trace && this.trace.length) {
                firebase.functions.httpsCallable('syncTrace')({
                    workspace: this.db.workspace.name,
                    txHash: transaction.hash,
                    steps: this.trace
                })
                    .catch(logger)
                    .finally(() => this.trace = []);
            }
        });
    }
    async getDefaultWorkspace() {
        var currentUser = await this.db.currentUser().get();
        var data = await currentUser.data();
        if (!data.currentWorkspace) {
            throw new Error('Please create a workspace first on https://app.tryethernal.com.');
        }
        var defaultWorkspace = await data.currentWorkspace.get();
        return Object.assign(Object.assign({}, defaultWorkspace.data()), { name: defaultWorkspace.id });
    }
    async setWorkspace() {
        try {
            let workspace = {};
            if (this.env.config.ethernal.workspace) {
                workspace = await this.db.getWorkspace(this.env.config.ethernal.workspace);
                if (!workspace) {
                    workspace = await this.getDefaultWorkspace();
                    logger(`Could not find workspace "${this.env.config.ethernal.workspace}", defaulting to ${workspace.name}`);
                }
                else {
                    logger(`Using workspace "${workspace.name}"`);
                }
            }
            else {
                workspace = await this.getDefaultWorkspace();
                logger(`Using default workspace "${workspace.name}"`);
            }
            this.db.workspace = workspace;
        }
        catch (error) {
            logger(error.message || 'Error while setting the workspace.');
        }
    }
    async login() {
        try {
            let email, password;
            email = this.env.config.ethernal.email;
            if (!email) {
                return logger('You are not logged in, please run "ethernal login".');
            }
            else {
                password = this.env.config.ethernal.password;
                if (!password) {
                    return logger('You are not logged in, please run "ethernal login".');
                }
            }
            const user = (await firebase.auth().signInWithEmailAndPassword(email, password)).user;
            logger(`Logged in with ${user.email}`);
            return user;
        }
        catch (_error) {
            if (_error.message)
                logger(_error.message);
            else
                logger('Error while retrieving your credentials, please run "ethernal login"');
        }
    }
    async getFormattedArtifact(targetContract) {
        const fullyQualifiedNames = await this.env.artifacts.getAllFullyQualifiedNames();
        var defaultBuildInfo = {
            output: {
                contracts: {},
                sources: {}
            }
        };
        let res = {
            name: '',
            address: '',
            abi: {},
            artifact: '',
            dependencies: {}
        };
        for (var i = 0; i < fullyQualifiedNames.length; i++) {
            var buildInfo = await this.env.artifacts.getBuildInfo(fullyQualifiedNames[i]);
            if (!buildInfo) {
                continue;
            }
            var buildInfoContracts = buildInfo.output.contracts;
            var buildInfoOutputSources = buildInfo.output.sources;
            var buildInfoInputSources = buildInfo.input.sources;
            for (var contractFile in buildInfoContracts) {
                for (var contractName in buildInfoContracts[contractFile]) {
                    var artifact = JSON.stringify({
                        contractName: contractName,
                        abi: buildInfoContracts[contractFile][contractName].abi,
                        ast: buildInfoOutputSources[contractFile].ast,
                        source: buildInfoInputSources[contractFile].content
                    });
                    if (contractName == targetContract.name) {
                        res.abi = buildInfoContracts[contractFile][contractName].abi;
                        res.name = contractName;
                        res.artifact = artifact;
                        res.address = targetContract.address;
                    }
                    else {
                        res.dependencies[contractName] = artifact;
                    }
                }
            }
        }
        return res;
    }
    sanitize(obj) {
        var res = {};
        res = Object.fromEntries(Object.entries(obj)
            .filter(([_, v]) => v != null));
        return res;
    }
}
exports.Ethernal = Ethernal;
//# sourceMappingURL=Ethernal.js.map